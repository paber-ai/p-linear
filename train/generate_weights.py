"""Generate Rust weights.rs from p-linear exported weights JSON.

This script consumes the JSON produced by export_weights(...) in
train_p_linear.py and emits a Rust source file that defines the hashing
configuration and per-head weight arrays used by the WASM inference engine.

Usage (from the p-linear project root):

    python -m train.generate_weights_rs \
        --weights-json artifacts/p_linear_weights.json \
        --output model/src/weights.rs

The generated Rust module is intended to replace the placeholder
`model/src/weights.rs` that ships with the repository.
"""

from __future__ import annotations
import argparse
import json
from pathlib import Path
from typing import Mapping


HEAD_ORDER = [
    "simple",
    "complex",
    "needs_tools",
    "needs_memory",
    "high_risk",
    "code_like",
]


def _load_weights_json(path: Path) -> Mapping[str, object]:
    data = json.loads(path.read_text(encoding="utf-8"))

    if "hashing" not in data or "heads" not in data:
        raise ValueError("Weights JSON must contain 'hashing' and 'heads' sections.")

    return data


def generate_weights_rs(weights_json: Path, output_rs: Path) -> None:
    data = _load_weights_json(weights_json)

    hashing = data["hashing"]
    heads: Mapping[str, Mapping[str, object]] = data["heads"]  # type: ignore[assignment]

    n_features = int(hashing["n_features"])
    ngram_min = int(hashing["ngram_min"])
    ngram_max = int(hashing["ngram_max"])

    lines: list[str] = []

    lines.append(
        "// Auto-generated by train/generate_weights_rs.py. Do not edit by hand.\n"
    )

    lines.append("\n")
    lines.append("pub const N_FEATURES: usize = ")
    lines.append(str(n_features))
    lines.append(";\n")
    lines.append("pub const NGRAM_MIN: usize = ")
    lines.append(str(ngram_min))
    lines.append(";\n")
    lines.append("pub const NGRAM_MAX: usize = ")
    lines.append(str(ngram_max))
    lines.append(";\n\n")

    lines.append("pub struct HeadWeights {\n")
    lines.append("    pub weights: &'static [f32],\n")
    lines.append("    pub bias: f32,\n")
    lines.append("}\n\n")

    # Per-head weight arrays and structs
    for head in HEAD_ORDER:
        head_data = heads.get(head)

        if head_data is None:
            raise ValueError(f"Missing head '{head}' in weights JSON.")

        weights = head_data.get("weights")
        bias = float(head_data.get("bias", 0.0))

        if not isinstance(weights, list):
            raise ValueError(f"Head '{head}' weights must be a list.")

        if len(weights) != n_features:
            raise ValueError(
                f"Head '{head}' expected {n_features} weights, got {len(weights)}."
            )

        ident = head.upper().replace("-", "_")

        lines.append(f"pub static {ident}_WEIGHTS: [f32; N_FEATURES] = [\n")
        # Emit weights with simple formatting; we do not attempt to pretty-print.
        # Rust's parser is fine with a long comma-separated list.
        chunk = ",".join(str(float(w)) for w in weights)
        lines.append("    ")
        lines.append(chunk)
        lines.append(",\n];\n\n")

        lines.append(f"pub static {ident}: HeadWeights = HeadWeights {{\n")
        lines.append(f"    weights: &{ident}_WEIGHTS,\n")
        lines.append(f"    bias: {bias}f32,\n")
        lines.append("};\n\n")

    # Aggregate struct for convenient access in lib.rs
    lines.append("pub struct AllHeads {\n")
    lines.append("    pub simple: &'static HeadWeights,\n")
    lines.append("    pub complex: &'static HeadWeights,\n")
    lines.append("    pub needs_tools: &'static HeadWeights,\n")
    lines.append("    pub needs_memory: &'static HeadWeights,\n")
    lines.append("    pub high_risk: &'static HeadWeights,\n")
    lines.append("    pub code_like: &'static HeadWeights,\n")
    lines.append("}\n\n")

    lines.append("pub static HEADS: AllHeads = AllHeads {\n")
    lines.append("    simple: &SIMPLE,\n")
    lines.append("    complex: &COMPLEX,\n")
    lines.append("    needs_tools: &NEEDS_TOOLS,\n")
    lines.append("    needs_memory: &NEEDS_MEMORY,\n")
    lines.append("    high_risk: &HIGH_RISK,\n")
    lines.append("    code_like: &CODE_LIKE,\n")
    lines.append("};\n")

    output_rs.write_text("".join(lines), encoding="utf-8")


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate Rust weights.rs from p-linear exported weights JSON.",
    )

    parser.add_argument(
        "--weights-json",
        type=str,
        required=True,
        help="Path to the JSON file produced by train_p_linear.export_weights().",
    )

    parser.add_argument(
        "--output",
        type=str,
        required=True,
        help="Path to write the generated Rust weights module (weights.rs).",
    )

    args = parser.parse_args()

    weights_json = Path(args.weights_json)

    if not weights_json.is_file():
        raise SystemExit(f"Weights JSON not found: {weights_json}")

    output_rs = Path(args.output)
    generate_weights_rs(weights_json, output_rs)


if __name__ == "__main__":
    main()
